> [실용적인 프론트엔드 테스팅 전략 - 김동우(NHN FE개발랩)](https://www.youtube.com/watch?v=q9d631Nl0_4&t=1075s)

# 프롤로그

테스트코드를 작성히며 항상 머릿속에 맴도는 질문

- 내가 작성하는 테스트가 정말 나에게 도움을 주고 있는 걸까?
- 프론트엔드 테스트는 대체 무엇을 어떻게 테스트해야 하는 걸까?

# 목차

## 1. 프론트엔드 테스팅 이해하기

- 테스트 코드를 작성하는 이유
- 프론트엔드 테스트가 어려운 이유 : 시각적 요소 검증

## 2. 시각적 테스트 vs 기능적 테스트

- 시각적 테스트와 기능적 테스트 분리하기
- Storybook을 사용한 시각적 테스트 관리

## 3. 단위 테스트 vs 통합테스트

- 단위 테스트, 통합 테스트의 구분과 장단점
- Cypress를 사용한 컴포넌트 단위의 통합 테스트 작성

---

## 개발자가 왜 테스트를 작성해야 할까요?

- 내가 뭔가 잘못 건드리면 꼭 알려줘
- 니가 괜찮다고 했으니, 이제 퇴근할게
- 라이브러리 업데이트 완료, 문제 없는거지?
- 이 기능을 추가하려면 구조를 바꿔야 하는데, 너만 믿고 한 번 해볼게
- 성능은 향상됐는데, 기능에는 문제 없겠지?
- 자, 이제 이 버그 다시는 볼 일 없겠지?

Confidence (자신감, 신뢰)

---

## 프론트엔드 vs 백엔드

테스트의 기본적인 형식은 입력값과 출력값을 검증하는 것이다.

| 구분 | 프론트엔드     | 백엔드       |
| ---- | -------------- | ------------ |
| 입력 | 마우스, 키보드 | HTTP(S) 요청 |
| 출력 | 시각적 정보    | HTTP(S) 응답 |

백엔드는 입/출력값이 데이터로 검증이 가능하지만 프론트엔드는 입력값이 사용자의 액션이기 떄문에 데이터라고 보기에는 애매하고 출력값은 화면이 바뀌는 것이다.

결국 근본적인 어려움의 원인은 입/출력을 데이터로서 코드로 검증하기 힘들기 때문이다.

---

## 프론트엔드의 입력과 출력

### 입력 데이터

- DOM 이벤트 : 마우스, 키보드, 터치 등의 입력 이벤트
  - 생성 : 브라우저의 이벤트 시뮬레이션 API 사용
- 라우팅/IO : URL 변경, 네트워크/로컬 파일, 로컬 스토리지/쿠키
  - 생성 : 브라우저 API Mocking / E2E 테스트 도구 사용

### 출력 데이터 (시각적 요소)

- 코드 관점 : HTML, CSS
  - 검증 : 생성된 HTML, CSS 코드의 내용을 비교
- 사용자 관점 : 브라우저가 렌더링한 화면(픽셀정보)
  - 검증 : 브라우저가 렌더링한 화면을 캡처해서 이미지로 비교

---

## 시각적 요소의 검증 (예제) - 카운터

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const increase = () => setCount(count + 1);
  const decrease = () => setCount(count - 1);

  return (
    <div className="simple-counter">
      <button className="dec" onClick={decrease}>
        -
      </button>
      <span className="value">{count}</span>
      <button className="inc" onClick={increase}>
        +
      </button>
    </div>
  );
}
```

### 시각적 요소의 검증 1 : HTML 비교

```javascript
it("생성시 버튼과 초기 값을 렌더링한다.", () => {
  const div = document.createElement("div");
  ReactDOM.render(<Conter />, div);

  expect(diffableHTML(div.innerHTML)).toBe(
    diffableHTML(`
      <div className="simple-counter">
        <button className="dec" onClick={decrease}>
          -
        </button>
        <span className="value">{count}</span>
        <button className="inc" onClick={increase}>
          +
        </button>
      </div>
    `)
  );
});
```

인덴트, 공백문자의 문제는 diffableHTML같은 라이브러리를 사용하여 해결 할 수 있다.

### 시각적요소의 검증 2 : 스냅샷 테스트 (Jest)

```javascript
it("생성시 버튼과 초기 값을 렌더링한다.", () => {
  const div = document.createElement("div");
  ReactDOM.render(<Conter />, div);

  expect(diffableHTML(div.innerHTML)).toMatchSnapshot();
});
```

`toMatchSnapshot` 함수가 실행되면 결과값을 파일로 저장하여 비교하는 방식

---

## HTML 비교의 문제점

테스트가 나에게 신뢰를 주는가?

- HTML 구조를 보고 실제 결과물 (픽셀 정보)를 예측할 수 있는가?
- 테스트가 성공하면 항상 의도된 결과가 나온다고 보장할 수 있는가?
- HTML/CSS를 리팩토링할 때 테스트가 도움을 주는가?

구현 상세 테스트 vs 동작 테스트

- 구현 상세(Implementation detail)에 대한 테스트를 지양하고, **동작(Begavior)을 테스트하라**
- private 메서드에 대한 테스트를 지양하고, **public 인터페이스를 테스트하라**
- 구현상세(private) : HTML/CSS → **동작(public) : 픽셀 정보**
