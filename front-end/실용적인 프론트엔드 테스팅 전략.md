> [실용적인 프론트엔드 테스팅 전략 - 김동우(NHN FE개발랩)](https://www.youtube.com/watch?v=q9d631Nl0_4&t=1075s)

# 프롤로그

테스트코드를 작성히며 항상 머릿속에 맴도는 질문

- 내가 작성하는 테스트가 정말 나에게 도움을 주고 있는 걸까?
- 프론트엔드 테스트는 대체 무엇을 어떻게 테스트해야 하는 걸까?

# 목차

## 1. 프론트엔드 테스팅 이해하기

- 테스트 코드를 작성하는 이유
- 프론트엔드 테스트가 어려운 이유 : 시각적 요소 검증

## 2. 시각적 테스트 vs 기능적 테스트

- 시각적 테스트와 기능적 테스트 분리하기
- Storybook을 사용한 시각적 테스트 관리

## 3. 단위 테스트 vs 통합테스트

- 단위 테스트, 통합 테스트의 구분과 장단점
- Cypress를 사용한 컴포넌트 단위의 통합 테스트 작성

---

## 개발자가 왜 테스트를 작성해야 할까요?

- 내가 뭔가 잘못 건드리면 꼭 알려줘
- 니가 괜찮다고 했으니, 이제 퇴근할게
- 라이브러리 업데이트 완료, 문제 없는거지?
- 이 기능을 추가하려면 구조를 바꿔야 하는데, 너만 믿고 한 번 해볼게
- 성능은 향상됐는데, 기능에는 문제 없겠지?
- 자, 이제 이 버그 다시는 볼 일 없겠지?

Confidence (자신감, 신뢰)

---

## 프론트엔드 vs 백엔드

테스트의 기본적인 형식은 입력값과 출력값을 검증하는 것이다.

| 구분 | 프론트엔드     | 백엔드       |
| ---- | -------------- | ------------ |
| 입력 | 마우스, 키보드 | HTTP(S) 요청 |
| 출력 | 시각적 정보    | HTTP(S) 응답 |

백엔드는 입/출력값이 데이터로 검증이 가능하지만 프론트엔드는 입력값이 사용자의 액션이기 떄문에 데이터라고 보기에는 애매하고 출력값은 화면이 바뀌는 것이다.

결국 근본적인 어려움의 원인은 입/출력을 데이터로서 코드로 검증하기 힘들기 때문이다.

---

## 프론트엔드의 입력과 출력

### 입력 데이터

- DOM 이벤트 : 마우스, 키보드, 터치 등의 입력 이벤트
  - 생성 : 브라우저의 이벤트 시뮬레이션 API 사용
- 라우팅/IO : URL 변경, 네트워크/로컬 파일, 로컬 스토리지/쿠키
  - 생성 : 브라우저 API Mocking / E2E 테스트 도구 사용

### 출력 데이터 (시각적 요소)

- 코드 관점 : HTML, CSS
  - 검증 : 생성된 HTML, CSS 코드의 내용을 비교
- 사용자 관점 : 브라우저가 렌더링한 화면(픽셀정보)
  - 검증 : 브라우저가 렌더링한 화면을 캡처해서 이미지로 비교

---

## 시각적 요소의 검증 (예제) - 카운터

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const increase = () => setCount(count + 1);
  const decrease = () => setCount(count - 1);

  return (
    <div className="simple-counter">
      <button className="dec" onClick={decrease}>
        -
      </button>
      <span className="value">{count}</span>
      <button className="inc" onClick={increase}>
        +
      </button>
    </div>
  );
}
```

### 시각적 요소의 검증 1 : HTML 비교

```javascript
it("생성시 버튼과 초기 값을 렌더링한다.", () => {
  const div = document.createElement("div");
  ReactDOM.render(<Conter />, div);

  expect(diffableHTML(div.innerHTML)).toBe(
    diffableHTML(`
      <div className="simple-counter">
        <button className="dec" onClick={decrease}>
          -
        </button>
        <span className="value">{count}</span>
        <button className="inc" onClick={increase}>
          +
        </button>
      </div>
    `)
  );
});
```

인덴트, 공백문자의 문제는 diffableHTML같은 라이브러리를 사용하여 해결 할 수 있다.

### 시각적요소의 검증 2 : 스냅샷 테스트 (Jest)

```javascript
it("생성시 버튼과 초기 값을 렌더링한다.", () => {
  const div = document.createElement("div");
  ReactDOM.render(<Conter />, div);

  expect(diffableHTML(div.innerHTML)).toMatchSnapshot();
});
```

`toMatchSnapshot` 함수가 실행되면 결과값을 파일로 저장하여 비교하는 방식

---

## HTML 비교의 문제점

테스트가 나에게 신뢰를 주는가?

- HTML 구조를 보고 실제 결과물 (픽셀 정보)를 예측할 수 있는가?
- 테스트가 성공하면 항상 의도된 결과가 나온다고 보장할 수 있는가?
- HTML/CSS를 리팩토링할 때 테스트가 도움을 주는가?

구현 상세 테스트 vs 동작 테스트

- 구현 상세(Implementation detail)에 대한 테스트를 지양하고, **동작(Begavior)을 테스트하라**
- private 메서드에 대한 테스트를 지양하고, **public 인터페이스를 테스트하라**
- 구현상세(private) : HTML/CSS → **동작(public) : 픽셀 정보**

---

### 시작적 요소의 검증 3 : 이미지 비교

처음 렌더링된 결과를 스크린 샷으로 저장하고 액션을 발생시킨 다음 결과의 스크린 샷을 저장하여 비교를 해본다. 따라서 픽셀 단위에서 변경점을 찾고 의도된 변화라면 스크린 샷을 갱신하면 되고, 의도된 변화가 아니라면 버그를 수정하면 된다.

---

## 시각적 회귀 테스트의 문제점

캡쳐 이미지의 신뢰성

- 픽셀 단위 비교 : 의미 있는 변경점을 찾기 어려움
- 운영체제, 브라우저 등의 렌더링 방식 차이
- 이미지/폰트 로딩 시간, 커서, 애니메이션 등으로 인한 캡처 시점 차이

결과 확인 및 이력 관리

- 커맨드 라인에서 확인 불가능 &#8594; 결과 확인을 위한 UI 필요
- 브라우저, 뷰포트 크기 등의 케이스별 이미지 파일 생성/관리
- 테스트 실행 단위별 이미지 파일 히스토리 관리

---

## 시각적 테스트 전문 도구

Visual Testing as a Service : `applitools`, `percy`, `chromatic`

- 캡처 이미지 안정화(캡처 시점 조절, 애니메이션 정지 등)
- 의미 있는 차이를 분석해서 화면에 표시 (머신 러닝 등 사용)
- 다양한 브라우저 실행 환경 제공
- 브라우저 및 뷰포트 사이즈별 이미지 생성/관리
- 병렬 실행을 통한 테스트 속도 향상
- 다양한 테스트 도구 연동 (Storybook, Selenium, Cypress..)
- 다양한 CI 환경과 연동 (Jenkins, Travis, CircleCI..)

---

## 시각적 테스트 도구 사용 예제 (Percy)

```javascript
const puppeteer = require("puppeteer");
const { percySnapshot } = require("@percy/puppeteer");

it("Visual Testing", async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  await page.goto("http://localhost:3000");
  await percySnapshot(page, "초기 상태");

  const btnInc = await page.$("button.inc");
  await btnInc.click();
  await percySnapshot(page, "+ 버튼 클릭 후");

  await browser.close();
});
```

---

## 시각적 테스트 for Everything?

테스트 환경 / 실행속도

- 스크린샷을 생성할 수 있는 환경(Selenium, Pupperteer 등)에서만 테스트 가능
- 테스트 실행 속도가 느림 &#8594; 빠른 피드백을 받을 수 없음 &#8594; 개발 속도 저하

테스트의 문서화 기능 / TDD

- 테스트의 의도가 코드에 명확하게 드러나지 않음 &#8594; 문서화 기능 X
- TDD 불가능 &#8594; 회귀 테스트 용도로만 사용

단일 테스트에 영향을 주는 요소

- **시각적 요소** : 레이아웃 변경, 폰트 변경, 색상 변경 등
- **기능적 요소** : 사용자 입력처리, 데이터 연산, 상태(State) 변경
- 테스트가 실패했을 때 원인을 파악하기 어려움

**&#8594; 시각적 요소와 기능적 요소를 분리하여 테스트 하는 것이 중요한 포인트**

---

## 시각적 테스트 vs 기능적 테스트

|                   | 시각적 테스트                        | 기능적 테스트                     |
| ----------------- | ------------------------------------ | --------------------------------- |
| 용도              | 회귀 테스트                          | 모든 종류의 테스트                |
| TDD               | 불가능                               | 가능                              |
| 실행 환경         | 브라우저 외부(조작 가능 환경)        | 브라우저 내/외부, Node.js         |
| 테스트 도구       | 외부 서비스 필요 (유료)              | Jest, Mocha, Jasmine, Puppeteer.. |
| 결과 확인         | 이미지 확인을 위한 UI 필요           | 커맨드 라인에서 확인 가능         |
| CI 연동/이력 관리 | 이미지 확인/관리를 위한 별도 UI 필요 | 빌트인 기능으로 가능              |

&#8594; 시각적 테스트를 하는 이유는 시각적 요소를 코드로 검증하는 것이 어렵기 때문에 분리를 하여 진행 하는 것이 효율적인 전략

---

## 기능적 테스트 예제 (검증코드)

```javascript
it("초기 값은 0이다.", () => {
  const value = container.querySelector(".value");
  expect(value.innerHTML).toBe("0");
});

it("+ 버튼 클릭 시 1 증가한다.", () => {
  const btnInc = container.querySelector("button.inc");
  const value = container.querySelector(".value");
  btnInc.click();
  expect(value.innerHTML).toBe("1");
});
```

테스트 포인트

- 값이 제대로 나오는가?
- 버튼이 제대로 동작하는가?

**&#8594; 시각적 요소를 완벽히 분리**

---

## 기능적 테스트 : 시각적 요소 의존성 제거

**셀렉터가 많은 연관성을 가진다**

DOM 탐색 : 잘못된 예

```javascript
container.querySelector(".box > .value"); // 부모 > 자식 선택자 사용
container.querySelector("span.value"); // 태그 선택자 사용
container.querySelector(".text.white"); // 시각적 표현을 위한 클래스명 사용
container.children[0]; // children, parent 등의 구조 속성 사용
```

DOM 탐색 : 올바른 예

```javascript
container.querySelector(".count-value"); // 기능만을 위한 의미있는 클래스명 사용
container.querySElector('[data-testid="count-value"]'); // 테스트를 위한 별도의 속성값 사용
```

---

## 기능적 테스트 : data-testid 사용예제

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const increase = () => setCount(count + 1);
  const decrease = () => setCount(count - 1);

  return (
    <div className="simple-counter">
      <button className="dec" data-testid="btn-inc" onClick={decrease}>
        -
      </button>
      <span className="value" data-testid="value">
        {count}
      </span>
      <button className="inc" data-testid="btn-dec" onClick={increase}>
        +
      </button>
    </div>
  );
}
```

```javascript
const getByTestId = (node, id) => node.querySelector(`[data-testid="${id}"]`);

it("초기 값은 0이다.", () => {
  const value = getByTestId(container, "value");
  expect(value.textContent).toBe("0");
});

it("+ 버튼 클릭시 1증가한다.", () => {
  const btnInc = getByTestId(container, "btn-inc");
  const value = getByTestId(container, "value");

  btnInc.click();

  expect(value.textContent).toBe("1");
});
```

**&#8594; 기능적 테스트에서 시각적 요소를 분리하면 CSS class나 DOM 구조가 변경되어도 영향을 받지 않는 기능적 테스트를 할 수 있다.**

---

## 시각적 테스트 : 기능적 요소 제외

**시각적 요소와 기능적 요소를 분리했으므로 기능 테스트를 수행할 필요가 없다**

```javascript
const puppeteer = require("puppeteer");
const { percySnapshot } = require("@percy/puppeteer");

it("Visual Testing", async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  await page.goto("http://localhost:3000");
  await percySnapshot(page, "초기 상태");

  // const btnInc = await page.$("button.inc");
  // await btnInc.click();
  // await percySnapshot(page, "+ 버튼 클릭 후");

  await browser.close();
});
```

---

## 시각적 테스트 : 케이스 검증

한 자리 수

- font-size: 5em

두 자리 수

- font-size: 4em

세 자리 수

- font-size: 3em
- letter-spacing: -0.1em

**&#8594; 다양한 시각적 케이스를 테스트하기 위해서는 기능이랑 결부되지 않은 상태로 통제할 수 있어야 한다.**

---

## UI 상태별 시각적 테스트 (준비)

초기값을 임의로 설정 할 수 있게 변경

```jsx
// Conter.js
function Counter({ initValue = 0 }) {
  const [count, setCount] = useState(initValue);
  ...
}
```

entry point를 만들어 컴포넌트 렌더링

```jsx
// entry/single-digit.js
ReactDOM.render(
  <Counter initValue={8} />,
  document.getElementById('root');
);
```

```jsx
// entry/double-digit.js
ReactDOM.render(
  <Counter initValue={76} />,
  document.getElementById('root');
);
```

```jsx
ReactDOM.render(
  <Counter initValue={386} />,
  document.getElementById('root');
);
// entry/triple-digit.js
```

---

## UI 상태별 시각적 테스트 (테스트 코드)

```javascript
...

it("Visual Testing", async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  await page.goto("http://localhost:3000/single-digit");
  await percySnapshot(page, "한 자리 수");

  await page.goto("http://localhost:3000/double-digit");
  await percySnapshot(page, "두 자리 수");

  await page.goto("http://localhost:3000/triple-digit");
  await percySnapshot(page, "세 자리 수");

  await browser.close();
});
```

&#8594; 엔트리 포인트를 각각 만들고 해야하나?

---

## Storybook : UI 컴포넌트 개발 환경

독립된 컴포넌트 개발 환경

- 전체 애플리케이션에서 컴포넌트를 분리해서 **독립된 개발 환경 제공**
- 통합된 상태의 환경보다 훨씬 빠른 피드백을 받으며 개발 가능
- 특히 시각적 요소 개발(HTML/CSS)에 특화된 개발 환경

컴포넌트의 다양한 상태를 등록/관리

- 특정한 상태의 컴포넌트를 미리 등록해 놓고 재사용
- 컴포넌트의 다양한 시각적 상태를 빠르게 파악할 수 있음
- 재현하기 어려운 복잡한 상태를 빠르게 재현 후 개발/수정 가능

---

## 스토리 작성

```jsx
import React from "react";
import Counter from "../src/Counter";

export default { title: "Simple Counter" };

export const singleDigit = () => <Counter initValue={8} />;
export const doubleDigit = () => <Counter initValue={76} />;
export const tripleDigit = () => <Counter initValue={386} />;
```

특정 케이스를 스토리 단위로 등록할 수 있기 때문에 개발시 불필요한 작업을 방지할 수 있다

- 초기 값을 변경했다가 원복
- 세 자리 수 케이스에 대해서 스타일을 변경하기 위해 count를 100번 누르기

---

## Storybook != 시각적 테스트

**테스트 도구는 아니지만 테스트에 굉장히 많은 도움을 준다**

시각적 요소 개발 환경

- 시각적 요소 개발을 위한 분리된 단위 테스트 환경
- 특히 HTML/CSS 개발 단계에서 빠른 피드백 제공

시각적 테스트 자동화를 위한 보조 도구

- 검증이 필요한 다양한 시각적 케이스를 최소한의 코드로 관리
- 수동으로 테스트할 때에도 많은 시간과 비용을 절약
- 자동화 도구를 도입할 때 추가 비용 없이 사용 가능

---

## Storybook의 활용 범위

디자인/기획 부서와의 커뮤니케이션

- 디자인 QA를 위한 구현 결과물 공유
- 구현 이슈나 프로토타이핑 결과를 공유하고 피드백 반영
- 디자인 시스템 가이드 문서

개발자 사이의 커뮤니케이션

- 공통 컴포넌트의 사용법 가이드 및 API 문서로 활용
- 예제 페이지 / 튜토리얼 등의 문서로 활용
