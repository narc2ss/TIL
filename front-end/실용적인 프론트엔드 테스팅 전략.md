> [실용적인 프론트엔드 테스팅 전략 - 김동우(NHN FE개발랩)](https://www.youtube.com/watch?v=q9d631Nl0_4&t=1075s)

# 프롤로그

테스트코드를 작성히며 항상 머릿속에 맴도는 질문

- 내가 작성하는 테스트가 정말 나에게 도움을 주고 있는 걸까?
- 프론트엔드 테스트는 대체 무엇을 어떻게 테스트해야 하는 걸까?

# 목차

## 1. 프론트엔드 테스팅 이해하기

- 테스트 코드를 작성하는 이유
- 프론트엔드 테스트가 어려운 이유 : 시각적 요소 검증

## 2. 시각적 테스트 vs 기능적 테스트

- 시각적 테스트와 기능적 테스트 분리하기
- Storybook을 사용한 시각적 테스트 관리

## 3. 단위 테스트 vs 통합테스트

- 단위 테스트, 통합 테스트의 구분과 장단점
- Cypress를 사용한 컴포넌트 단위의 통합 테스트 작성

---

## 개발자가 왜 테스트를 작성해야 할까요?

- 내가 뭔가 잘못 건드리면 꼭 알려줘
- 니가 괜찮다고 했으니, 이제 퇴근할게
- 라이브러리 업데이트 완료, 문제 없는거지?
- 이 기능을 추가하려면 구조를 바꿔야 하는데, 너만 믿고 한 번 해볼게
- 성능은 향상됐는데, 기능에는 문제 없겠지?
- 자, 이제 이 버그 다시는 볼 일 없겠지?

Confidence (자신감, 신뢰)

---

## 프론트엔드 vs 백엔드

테스트의 기본적인 형식은 입력값과 출력값을 검증하는 것이다.

| 구분 | 프론트엔드     | 백엔드       |
| ---- | -------------- | ------------ |
| 입력 | 마우스, 키보드 | HTTP(S) 요청 |
| 출력 | 시각적 정보    | HTTP(S) 응답 |

백엔드는 입/출력값이 데이터로 검증이 가능하지만 프론트엔드는 입력값이 사용자의 액션이기 떄문에 데이터라고 보기에는 애매하고 출력값은 화면이 바뀌는 것이다.

결국 근본적인 어려움의 원인은 입/출력을 데이터로서 코드로 검증하기 힘들기 때문이다.

---

## 프론트엔드의 입력과 출력

### 입력 데이터

- DOM 이벤트 : 마우스, 키보드, 터치 등의 입력 이벤트
  - 생성 : 브라우저의 이벤트 시뮬레이션 API 사용
- 라우팅/IO : URL 변경, 네트워크/로컬 파일, 로컬 스토리지/쿠키
  - 생성 : 브라우저 API Mocking / E2E 테스트 도구 사용

### 출력 데이터 (시각적 요소)

- 코드 관점 : HTML, CSS
  - 검증 : 생성된 HTML, CSS 코드의 내용을 비교
- 사용자 관점 : 브라우저가 렌더링한 화면(픽셀정보)
  - 검증 : 브라우저가 렌더링한 화면을 캡처해서 이미지로 비교

---

## 시각적 요소의 검증 (예제) - 카운터

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const increase = () => setCount(count + 1);
  const decrease = () => setCount(count - 1);

  return (
    <div className="simple-counter">
      <button className="dec" onClick={decrease}>
        -
      </button>
      <span className="value">{count}</span>
      <button className="inc" onClick={increase}>
        +
      </button>
    </div>
  );
}
```

### 시각적 요소의 검증 1 : HTML 비교

```javascript
it("생성시 버튼과 초기 값을 렌더링한다.", () => {
  const div = document.createElement("div");
  ReactDOM.render(<Conter />, div);

  expect(diffableHTML(div.innerHTML)).toBe(
    diffableHTML(`
      <div className="simple-counter">
        <button className="dec" onClick={decrease}>
          -
        </button>
        <span className="value">{count}</span>
        <button className="inc" onClick={increase}>
          +
        </button>
      </div>
    `)
  );
});
```

인덴트, 공백문자의 문제는 diffableHTML같은 라이브러리를 사용하여 해결 할 수 있다.

### 시각적요소의 검증 2 : 스냅샷 테스트 (Jest)

```javascript
it("생성시 버튼과 초기 값을 렌더링한다.", () => {
  const div = document.createElement("div");
  ReactDOM.render(<Conter />, div);

  expect(diffableHTML(div.innerHTML)).toMatchSnapshot();
});
```

`toMatchSnapshot` 함수가 실행되면 결과값을 파일로 저장하여 비교하는 방식

---

## HTML 비교의 문제점

테스트가 나에게 신뢰를 주는가?

- HTML 구조를 보고 실제 결과물 (픽셀 정보)를 예측할 수 있는가?
- 테스트가 성공하면 항상 의도된 결과가 나온다고 보장할 수 있는가?
- HTML/CSS를 리팩토링할 때 테스트가 도움을 주는가?

구현 상세 테스트 vs 동작 테스트

- 구현 상세(Implementation detail)에 대한 테스트를 지양하고, **동작(Begavior)을 테스트하라**
- private 메서드에 대한 테스트를 지양하고, **public 인터페이스를 테스트하라**
- 구현상세(private) : HTML/CSS → **동작(public) : 픽셀 정보**

---

### 시작적 요소의 검증 3 : 이미지 비교

처음 렌더링된 결과를 스크린 샷으로 저장하고 액션을 발생시킨 다음 결과의 스크린 샷을 저장하여 비교를 해본다. 따라서 픽셀 단위에서 변경점을 찾고 의도된 변화라면 스크린 샷을 갱신하면 되고, 의도된 변화가 아니라면 버그를 수정하면 된다.

---

## 시각적 회귀 테스트의 문제점

캡쳐 이미지의 신뢰성

- 픽셀 단위 비교 : 의미 있는 변경점을 찾기 어려움
- 운영체제, 브라우저 등의 렌더링 방식 차이
- 이미지/폰트 로딩 시간, 커서, 애니메이션 등으로 인한 캡처 시점 차이

결과 확인 및 이력 관리

- 커맨드 라인에서 확인 불가능 &#8594; 결과 확인을 위한 UI 필요
- 브라우저, 뷰포트 크기 등의 케이스별 이미지 파일 생성/관리
- 테스트 실행 단위별 이미지 파일 히스토리 관리

---

## 시각적 테스트 전문 도구

Visual Testing as a Service : `applitools`, `percy`, `chromatic`

- 캡처 이미지 안정화(캡처 시점 조절, 애니메이션 정지 등)
- 의미 있는 차이를 분석해서 화면에 표시 (머신 러닝 등 사용)
- 다양한 브라우저 실행 환경 제공
- 브라우저 및 뷰포트 사이즈별 이미지 생성/관리
- 병렬 실행을 통한 테스트 속도 향상
- 다양한 테스트 도구 연동 (Storybook, Selenium, Cypress..)
- 다양한 CI 환경과 연동 (Jenkins, Travis, CircleCI..)

---

## 시각적 테스트 도구 사용 예제 (Percy)

```javascript
const puppeteer = require("puppeteer");
const { percySnapshot } = require("@percy/puppeteer");

it("Visual Testing", async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  await page.goto("http://localhost:3000");
  await percySnapshot(page, "초기 상태");

  const btnInc = await page.$("button.inc");
  await btnInc.click();
  await percySnapshot(page, "+ 버튼 클릭 후");

  await browser.close();
});
```

---

## 시각적 테스트 for Everything?

테스트 환경 / 실행속도

- 스크린샷을 생성할 수 있는 환경(Selenium, Pupperteer 등)에서만 테스트 가능
- 테스트 실행 속도가 느림 &#8594; 빠른 피드백을 받을 수 없음 &#8594; 개발 속도 저하

테스트의 문서화 기능 / TDD

- 테스트의 의도가 코드에 명확하게 드러나지 않음 &#8594; 문서화 기능 X
- TDD 불가능 &#8594; 회귀 테스트 용도로만 사용

단일 테스트에 영향을 주는 요소

- **시각적 요소** : 레이아웃 변경, 폰트 변경, 색상 변경 등
- **기능적 요소** : 사용자 입력처리, 데이터 연산, 상태(State) 변경
- 테스트가 실패했을 때 원인을 파악하기 어려움

**&#8594; 시각적 요소와 기능적 요소를 분리하여 테스트 하는 것이 중요한 포인트**
